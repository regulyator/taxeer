// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: record.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRecord = `-- name: CreateRecord :one
INSERT INTO taxeer_record (taxeer_user_id, "date", income_value, income_currency, rate)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, taxeer_user_id, date, income_value, income_currency, rate
`

type CreateRecordParams struct {
	TaxeerUserID   uuid.UUID
	Date           time.Time
	IncomeValue    float64
	IncomeCurrency string
	Rate           float64
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (TaxeerRecord, error) {
	row := q.db.QueryRowContext(ctx, createRecord,
		arg.TaxeerUserID,
		arg.Date,
		arg.IncomeValue,
		arg.IncomeCurrency,
		arg.Rate,
	)
	var i TaxeerRecord
	err := row.Scan(
		&i.ID,
		&i.TaxeerUserID,
		&i.Date,
		&i.IncomeValue,
		&i.IncomeCurrency,
		&i.Rate,
	)
	return i, err
}

const getAllRecordByUserId = `-- name: GetAllRecordByUserId :many
SELECT id, taxeer_user_id, date, income_value, income_currency, rate
FROM taxeer_record
WHERE taxeer_user_id = $1
`

func (q *Queries) GetAllRecordByUserId(ctx context.Context, taxeerUserID uuid.UUID) ([]TaxeerRecord, error) {
	rows, err := q.db.QueryContext(ctx, getAllRecordByUserId, taxeerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaxeerRecord
	for rows.Next() {
		var i TaxeerRecord
		if err := rows.Scan(
			&i.ID,
			&i.TaxeerUserID,
			&i.Date,
			&i.IncomeValue,
			&i.IncomeCurrency,
			&i.Rate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastNRecordByUserId = `-- name: GetLastNRecordByUserId :many
SELECT id, taxeer_user_id, date, income_value, income_currency, rate
FROM taxeer_record
WHERE taxeer_user_id = $1
ORDER BY date desc
LIMIT $2
`

type GetLastNRecordByUserIdParams struct {
	TaxeerUserID uuid.UUID
	Limit        int32
}

func (q *Queries) GetLastNRecordByUserId(ctx context.Context, arg GetLastNRecordByUserIdParams) ([]TaxeerRecord, error) {
	rows, err := q.db.QueryContext(ctx, getLastNRecordByUserId, arg.TaxeerUserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaxeerRecord
	for rows.Next() {
		var i TaxeerRecord
		if err := rows.Scan(
			&i.ID,
			&i.TaxeerUserID,
			&i.Date,
			&i.IncomeValue,
			&i.IncomeCurrency,
			&i.Rate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordByUserIdAndDateBetweenOrderedByDateDesc = `-- name: GetRecordByUserIdAndDateBetweenOrderedByDateDesc :many
SELECT id, taxeer_user_id, date, income_value, income_currency, rate
FROM taxeer_record
WHERE taxeer_user_id = $1
AND date between $2 and $3
ORDER BY date desc
`

type GetRecordByUserIdAndDateBetweenOrderedByDateDescParams struct {
	TaxeerUserID uuid.UUID
	Date         time.Time
	Date_2       time.Time
}

func (q *Queries) GetRecordByUserIdAndDateBetweenOrderedByDateDesc(ctx context.Context, arg GetRecordByUserIdAndDateBetweenOrderedByDateDescParams) ([]TaxeerRecord, error) {
	rows, err := q.db.QueryContext(ctx, getRecordByUserIdAndDateBetweenOrderedByDateDesc, arg.TaxeerUserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaxeerRecord
	for rows.Next() {
		var i TaxeerRecord
		if err := rows.Scan(
			&i.ID,
			&i.TaxeerUserID,
			&i.Date,
			&i.IncomeValue,
			&i.IncomeCurrency,
			&i.Rate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecordIncomeCurrency = `-- name: UpdateRecordIncomeCurrency :exec
UPDATE taxeer_record
SET income_currency = $2
WHERE id = $1
`

type UpdateRecordIncomeCurrencyParams struct {
	ID             uuid.UUID
	IncomeCurrency string
}

func (q *Queries) UpdateRecordIncomeCurrency(ctx context.Context, arg UpdateRecordIncomeCurrencyParams) error {
	_, err := q.db.ExecContext(ctx, updateRecordIncomeCurrency, arg.ID, arg.IncomeCurrency)
	return err
}

const updateRecordIncomeValue = `-- name: UpdateRecordIncomeValue :exec
UPDATE taxeer_record
SET income_value = $2
WHERE id = $1
`

type UpdateRecordIncomeValueParams struct {
	ID          uuid.UUID
	IncomeValue float64
}

func (q *Queries) UpdateRecordIncomeValue(ctx context.Context, arg UpdateRecordIncomeValueParams) error {
	_, err := q.db.ExecContext(ctx, updateRecordIncomeValue, arg.ID, arg.IncomeValue)
	return err
}

const updateRecordRate = `-- name: UpdateRecordRate :exec
UPDATE taxeer_record
SET rate = $2
WHERE id = $1
`

type UpdateRecordRateParams struct {
	ID   uuid.UUID
	Rate float64
}

func (q *Queries) UpdateRecordRate(ctx context.Context, arg UpdateRecordRateParams) error {
	_, err := q.db.ExecContext(ctx, updateRecordRate, arg.ID, arg.Rate)
	return err
}
